#!/usr/bin/env node
/**
 * SVG Sprite Builder
 * Combines all SVGs in public/assets/images into a single sprite
 * Generates: misc/sprite.svg (copied to dist/ by Vite) + public/icons.generated.ts
 */

const fs = require("fs")
const path = require("path")

const ICONS_DIR = path.resolve(__dirname, "../public/assets/images")
const SPRITE_OUTPUT = path.resolve(__dirname, "../misc/sprite.svg")
const TS_OUTPUT = path.resolve(__dirname, "../public/icons.generated.ts")

function extractSvgAttributes(svgContent) {
  const svgTagMatch = svgContent.match(/<svg([^>]*)>/i)
  if (!svgTagMatch) return { viewBox: "0 0 24 24", fill: null, stroke: null }
  
  const attrs = svgTagMatch[1]
  const viewBoxMatch = attrs.match(/viewBox=["']([^"']+)["']/)
  const fillMatch = attrs.match(/fill=["']([^"']+)["']/)
  const strokeMatch = attrs.match(/stroke=["']([^"']+)["']/)
  
  return {
    viewBox: viewBoxMatch ? viewBoxMatch[1] : "0 0 24 24",
    fill: fillMatch ? fillMatch[1] : null,
    stroke: strokeMatch ? strokeMatch[1] : null,
  }
}

function extractSvgContent(svgContent) {
  let content = svgContent.replace(/<\?xml[^?]*\?>/gi, "")
  const match = content.match(/<svg[^>]*>([\s\S]*)<\/svg>/i)
  return match ? match[1].trim() : ""
}

function toIconId(filename) {
  // heroicons-check.svg -> heroicons-check
  return path.basename(filename, ".svg")
}

function toCamelCase(str) {
  // heroicons-check -> heroiconsCheck
  // heroicons-chat-alt-2 -> heroiconsChatAlt2
  return str.replace(/-([a-z0-9])/g, (_, char) => char.toUpperCase())
}

function build() {
  const svgFiles = fs.readdirSync(ICONS_DIR).filter((f) => f.endsWith(".svg"))

  const symbols = []
  const iconEntries = []

  for (const file of svgFiles) {
    const filePath = path.join(ICONS_DIR, file)
    const content = fs.readFileSync(filePath, "utf-8")
    const id = toIconId(file)
    const { viewBox, fill, stroke } = extractSvgAttributes(content)
    const inner = extractSvgContent(content)

    // Build <symbol> for sprite, preserving fill/stroke from original SVG
    let symbolAttrs = `id="${id}" viewBox="${viewBox}"`
    if (fill) symbolAttrs += ` fill="${fill}"`
    if (stroke) symbolAttrs += ` stroke="${stroke}"`
    symbols.push(`  <symbol ${symbolAttrs}>${inner}</symbol>`)

    // Build TS entry
    const varName = toCamelCase(id)
    iconEntries.push(`export const ${varName}: SpriteSymbol = { id: "${id}", viewBox: "${viewBox}" }`)
  }

  // Generate sprite.svg
  const sprite = `<svg xmlns="http://www.w3.org/2000/svg" style="display:none">
${symbols.join("\n")}
</svg>`

  // Ensure dist directory exists
  const distDir = path.dirname(SPRITE_OUTPUT)
  if (!fs.existsSync(distDir)) {
    fs.mkdirSync(distDir, { recursive: true })
  }

  fs.writeFileSync(SPRITE_OUTPUT, sprite)
  console.log(`✓ Generated ${SPRITE_OUTPUT} (${svgFiles.length} icons)`)

  // Generate TypeScript file
  const tsContent = `// Auto-generated by scripts/build-sprites.js - DO NOT EDIT
// Run: npm run build:sprites

interface SpriteSymbol {
  id: string
  viewBox: string
}

${iconEntries.join("\n")}

// Re-export all icons as a map for dynamic lookup
export const icons: Record<string, SpriteSymbol> = {
${svgFiles.map((f) => `  "${toIconId(f)}": ${toCamelCase(toIconId(f))}`).join(",\n")}
}
`

  fs.writeFileSync(TS_OUTPUT, tsContent)
  console.log(`✓ Generated ${TS_OUTPUT}`)
}

build()

