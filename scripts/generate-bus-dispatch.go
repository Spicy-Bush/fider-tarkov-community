//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type Handler struct {
	FuncName   string
	MsgType    string
	MsgPkg     string
	SourceFile string
	ImportPath string
}

// This generator creates dispatch_gen.go in app/pkg/bus/ which enables reflection free
// message dispatching for the bus system
//
// the original bus.Dispatch() used reflect.ValueOf(handler).Call() to invoke handlers,
// which adds a lot of CPU overhead. This generator creates a type switch that directly
// calls handlers without any reflection
//
// It scans app/services/ for all bus.AddHandler() calls
// extracts the handler function and its message type (e.g., *query.SearchPosts)
// generates a typed function variable for each handler (e.g., qSearchPostsHandler)
// a registerTypedHandler() function that populates these variables via type assertion
// a dispatchTyped() function with a type switch that calls handlers directly
//
// the generated code is automatically ran on build, so there's no real need to run it manually

func main() {
	handlers := make(map[string]*Handler)

	servicesDir := "app/services"

	packages := make(map[string]map[string]*ast.FuncDecl)
	packageImportPaths := make(map[string]string)

	err := filepath.Walk(servicesDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}

		dir := filepath.Dir(path)
		if packages[dir] == nil {
			packages[dir] = make(map[string]*ast.FuncDecl)
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return nil
		}

		relPath := strings.TrimPrefix(dir, "app/services/")
		packageImportPaths[dir] = "github.com/Spicy-Bush/fider-tarkov-community/app/services/" + strings.ReplaceAll(relPath, "\\", "/")

		for _, decl := range node.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok && fn.Recv == nil {
				packages[dir][fn.Name.Name] = fn
			}
		}

		return nil
	})

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error collecting functions: %v\n", err)
		os.Exit(1)
	}

	err = filepath.Walk(servicesDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}

		dir := filepath.Dir(path)
		funcSignatures := packages[dir]

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return nil
		}

		ast.Inspect(node, func(n ast.Node) bool {
			call, ok := n.(*ast.CallExpr)
			if !ok {
				return true
			}

			sel, ok := call.Fun.(*ast.SelectorExpr)
			if !ok {
				return true
			}

			ident, ok := sel.X.(*ast.Ident)
			if !ok || ident.Name != "bus" || sel.Sel.Name != "AddHandler" {
				return true
			}

			if len(call.Args) != 1 {
				return true
			}

			handlerIdent, ok := call.Args[0].(*ast.Ident)
			if !ok {
				return true
			}

			funcName := handlerIdent.Name
			fn := funcSignatures[funcName]
			if fn == nil {
				return true
			}

			if fn.Type.Params == nil || len(fn.Type.Params.List) < 2 {
				return true
			}

			msgParam := fn.Type.Params.List[1]
			starExpr, ok := msgParam.Type.(*ast.StarExpr)
			if !ok {
				return true
			}

			var msgPkg, msgType string
			switch x := starExpr.X.(type) {
			case *ast.SelectorExpr:
				if pkgIdent, ok := x.X.(*ast.Ident); ok {
					msgPkg = pkgIdent.Name
					msgType = x.Sel.Name
				}
			case *ast.Ident:
				msgType = x.Name
			}

			if msgType == "" {
				return true
			}

			key := msgPkg + "." + msgType
			handlers[key] = &Handler{
				FuncName:   funcName,
				MsgType:    msgType,
				MsgPkg:     msgPkg,
				SourceFile: path,
				ImportPath: packageImportPaths[dir],
			}

			return true
		})

		return nil
	})

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error walking services: %v\n", err)
		os.Exit(1)
	}

	var keys []string
	for k := range handlers {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	fmt.Printf("// Found %d handlers\n", len(handlers))

	var buf bytes.Buffer
	buf.WriteString("// Code generated by scripts/generate-bus-dispatch.go. DO NOT EDIT.\n")
	buf.WriteString("//go:generate go run ../scripts/generate-bus-dispatch.go\n\n")
	buf.WriteString("package bus\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"fmt\"\n\n")
	buf.WriteString("\t\"github.com/Spicy-Bush/fider-tarkov-community/app/models/cmd\"\n")
	buf.WriteString("\t\"github.com/Spicy-Bush/fider-tarkov-community/app/models/query\"\n")
	buf.WriteString(")\n\n")

	for _, k := range keys {
		h := handlers[k]
		varName := strings.ToLower(h.MsgPkg[:1]) + h.MsgType + "Handler"
		buf.WriteString(fmt.Sprintf("var %s func(context.Context, *%s.%s) error\n", varName, h.MsgPkg, h.MsgType))
	}

	buf.WriteString("\nvar useTypedDispatch bool\n\n")
	buf.WriteString("func EnableTypedDispatch() { useTypedDispatch = true }\n")
	buf.WriteString("func DisableTypedDispatch() { useTypedDispatch = false }\n\n")

	buf.WriteString("func registerTypedHandler(handler HandlerFunc) {\n")
	buf.WriteString("\tswitch fn := handler.(type) {\n")

	for _, k := range keys {
		h := handlers[k]
		varName := strings.ToLower(h.MsgPkg[:1]) + h.MsgType + "Handler"
		buf.WriteString(fmt.Sprintf("\tcase func(context.Context, *%s.%s) error:\n", h.MsgPkg, h.MsgType))
		buf.WriteString(fmt.Sprintf("\t\t%s = fn\n", varName))
	}

	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func dispatchTyped(ctx context.Context, msg Msg) error {\n")
	buf.WriteString("\tswitch m := msg.(type) {\n")

	for _, k := range keys {
		h := handlers[k]
		varName := strings.ToLower(h.MsgPkg[:1]) + h.MsgType + "Handler"
		buf.WriteString(fmt.Sprintf("\tcase *%s.%s:\n", h.MsgPkg, h.MsgType))
		buf.WriteString(fmt.Sprintf("\t\tif %s == nil {\n", varName))
		buf.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"handler not registered: %s.%s\")\n", h.MsgPkg, h.MsgType))
		buf.WriteString("\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\treturn %s(ctx, m)\n", varName))
	}

	buf.WriteString("\tdefault:\n")
	buf.WriteString("\t\treturn fmt.Errorf(\"no typed handler for message type: %T\", msg)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n")

	outPath := "app/pkg/bus/dispatch_gen.go"
	if err := os.WriteFile(outPath, buf.Bytes(), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing file: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("\nGenerated: %s\n", outPath)
}
